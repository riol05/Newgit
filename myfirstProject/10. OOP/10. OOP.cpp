
#include <iostream>

using namespace std;


/****************************************************************
 * 객체지향 프로그래밍(Object-Oriented Programming)
 *
 * 프로그램 설계방법론이자 개념의 일종
 * 프로그램을 서로 상호작용하는 객체를 기본 단위로 구성하는 방식
 ****************************************************************/

 // <절차지향과 객체지향>
 // 절차지향 : 프로그램의 순차적인 처리를 위주로 설계하는 방법론
 // 객체지향 : 서로 상호작용하는 객체를 기본 단위로 구성하는 방법론


 // <객체지향의 등장배경>
 // 물리적인 하드웨어의 발전이 빠르게 진행되었으며, 소프트웨어의 중요성이 빠르게 올라감
 // 기존 절차지향의 방식으로는 복잡한 구조에 대한 설계가 힘들어졌으며 객체지향의 방식이 대안이 됨


 // <객체지향의 장단점>
 // 장점 :   1. 객체단위로 관리하기 때문에 디버깅이 유리함
 //          2. 상속을 통한 코드의 재사용성이 좋음
 //          3. 잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로 생산성을 향상
 // 단점 :   1. 설계에 시간이 많이 소비되며 신중해야함
 //          2. 절차지향언어에 비해 상대적으로 실행 속도가 느림 // 상대적으로 느릴뿐 신경쓰일 정도로 느리진 않다. 


 // <객체지향 4특징>
 // 캡슐화  : 객체를 상태와 기능으로 묶는 것을 의미하며, 객체의 내부 상태와 기능을 숨기고, 허용한 상태와 기능만의 액세스 허용
 // 다형성  : 부모클래스의 함수를 자식클래스에서 재정의하여 자식클래스의 다른 반응을 구현
 // 추상화  : 관련 특성 및 엔터티의 상호 작용을 클래스로 모델링하여 시스템의 추상적 표현을 정의
 // 상속    : 부모클래스의 모든 기능을 가지는 자식클래스를 설계하는 방법


 // <객체설계 5원칙>
 // (S)단일 책임 원칙       : 객체는 오직 하나의 책임을 가져야 함
 // (O)개방 폐쇄 원칙       : 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 함
 // (L)리스코프 치환 원칙    : 자식클래스는 언제나 자신의 부모클래스를 대체할 수 있어야 함
 // (I)인터페이스 분리 원칙  : 인터페이스는 작은 단위들로 분리시켜 구성하며, 사용하지 않는 함수는 포함하지 않아야 함
 // (D)의존성 역전 원칙      : 객체는 하위클래스(상위클래스를 구현한 객체)보다 상위클래스(추상성이 높은 상위 개념)에 의존해야함



 /****************************************************************
  * 클래스 (class)                      // 클래스는 빵틀 , 인스턴스는 빵
  *
  * 객체지향 프로그래밍에 객체를 만들기 위한 형식
  * 클래스는 객체를 만들기 위한 설계도이며, 만들어진 객체는 인스턴스라 함
  ****************************************************************/

  // <클래스 선언>
  // class 클래스이름 { 클래스내용 };
  // 클래스 내용으로는 변수와 함수가 포함 가능
  // 클래스에 포함한 변수를 멤버변수(필드), 클래스에 포함한 함수를 멤버함수(메소드)라고 함
class Student
{
public: // public 접근제한자
    int math;
    int english;
    int science;

    float Average()
    {
        return (math + english + science) / 3.0f;
    }
};

class Monster  // 구조체와 거의 비슷하다.
{
public:
    string name;
    int hp;
    int mp;
    int attack;
    int defence;
    void attack()
    {
        cout << "플레이어를 " << name << "이/가" << attack << "만큼 공격합니다." << endl;

    }
};

// <구조체와 클래스의 차이>
// C++에서 클래스와 구조체는 본질적으로 같음
// 차이점은 클래스의 기본접근제한자는 private, 구조체의 기본접근제한자는 public

class DataClass // 객체 생성 용도
{
    int value;
};

struct DataStruct // 데이터 집합 용도
{
    int value;
};

void Main1()
{
    DataClass dataClass;
    // dataClass.value;      // 기본접근제한자 public 외부사용불가

    DataStruct dataStruct;
    dataStruct.value;        // 기본접근제한자 private 외부사용가능
}

int main()
{

}
