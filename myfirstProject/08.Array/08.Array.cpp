#include <iostream>
using namespace std;

int main()
{
    /************************************************************************************
     * 배열 (Array)
     *
     * 같은 자료형의 여러 변수를 연속적으로 배치하여 저장한 데이터 유형
     * 배열을 구성하는 각 변수를 요소 (element)라고 하며, 요소가 연속적으로 모여 배열을 구성함
     ************************************************************************************/

     // <배열 선언>
     // 자료형 배열이름[배열길이];
    int array[5];                   // int 자료형의 변수 5개를 연속적으로 선언
    array[0] = 2; //int 자료형 의 첫번째 변수
    array[1] = 6; // int 자료형의 두번째 변수 // 초기화 하지 않으면 쓰레기 값이 들어가게된다. int array[5] = {0}; 쓰레기 값을 넣기 싫다면 초기화를 전체적으로 해준다.
    int numbers[3] = { 1, 3, 5 };   // int 자료형의 변수 3개를 연속적으로 선언과 초기화를 진행
    //int numbers[3] = { 1, 3 };    // 이렇게 초기화를 안해주게 되면 한 숫자는 0이 되어버린다.
    int ints[] = { 5, 7, 9, 8 };    // 배열의 길이를 지정하지 않았지만 4개를 사용함으로 4 길이의 배열을 선언


    // <인덱스 (index)>
    // 배열의 요소를 접근하기 위한 수단으로 [](하위연산자) 사이에 인덱스를 통해 요소에 접근
    // 인덱스는 0부터 시작하며, 길이가 N인 배열은 N-1까지 인덱스를 가질 수 있음
    cout << "numbers 배열의 1번째 요소는 " << numbers[0] << endl;
    cout << "numbers 배열의 3번째 요소는 " << numbers[2] << endl;

    // <배열의 길이>
   // 배열은 같은 자료형을 연속적으로 배치하는 방식이므로 전체크기 / 하나의크기 를 통해 길이를 확인가능
   // sizeof(배열이름) / sizeof(배열이름[0])
    cout << "numbers 배열의 길이는 " << sizeof(numbers) / sizeof(numbers[0]) << endl;
    //                                 12byte가 나온다.         4byte       // 3개가 나오게된다.
/*
    int count;
    cout << "몬스터의 숫자를 입력하세요 : ";
    cin >> count;
    int array1[count]; // 이것은 불가능하다.배열의 길이는 컴파일시에 정해져 있어야한다. 메모리의 크기가 확정 되어 있어야한다.
    */



    // <고정 배열>
    // 배열의 길이는 컴파일시에 정해져 있어야 하며 변경할 수 없음
    // 프로그램 동작중(런타임)에 따라 달라질 수 있는 경우의 크기는 사용할 수 없음
    int array1[5];          // 사용가능

    const int LENGTH = 5;
    int array2[LENGTH];     // 사용가능

    int temp = 3;
    // int array3[temp];    // 사용불가능 나중에 temp= 5; 로 변경할수도 있기때문에 유동적인 변수의 값은 가질수가 없다.


    // <동적 배열>
    // 동적할당을 진행하는 경우 런타임시에 배열의 크기를 원하는만큼 할당 할 수 있음
    // 프로그램 동작중(런타임)에 따라 달라질 수 있는 경우의 크기는 사용할 수 있음
    int size = 10;
    cout << "배열의 크기를 입력하세요 : ";
    cin >> size;
    int* array3 = new int[size];

    delete[] array3; // delete 에 [] 를 표시해줘서 배열 전체를 삭제해야한다.




    // <배열 사용시 주의사항>
   // 배열의 길이를 벗어나는 인덱스 사용시 의도하지 않은 메모리 위치를 변경할 수 있음
   // 반드시 배열을 사용시 배열의 길이를 벗어나지 않는 인덱스 사용을 진행해야 함
   // array[-1] = 20;      // 주의! 프로그램을 손상시킬 수 있음 // 다른 부분의 메모리를 사용하게 된다.
   // array[6] = 10;        // 지정해둔 범위를 벗어나는 인덱스 사용을 하는것은 주의하자. 의도하지 않은 메모리의 위치를 변경하게됨



   // <다차원 배열>
   // 배열의 요소로 배열을 저장하도록 하여 여러 차원을 가진 배열처럼 사용할 수 있음
    int matrix[3][4];      // int 자료형의 변수를 4개를 가진 배열을 3개 만들어 12개의 int를 가진 2차원 배열 선언
    /*
    [0][0]  [0][1]  [0][2]  [0][3]
    [1][0]  [1][1]  [1][2]  [1][3]
    [2][0]  [2][1]  [2][2]  [2][3]
    */
    int table[3][2] = { {0, 1}, {2, 3}, {4, 5} };   // 이차원 배열의 초기화
    int cube[2][3][4];      // 2 * 3 * 4 = 24, int 자료형의 변수를 총 24개 가진 3차원 배열


    // <배열과 반복>
    // 배열의 인덱스를 반복하여 증가시키며 사용하는 경우 배열의 모든 요소를 반복 수행하는데 용이함
    int scores[] = { 84, 92, 76, 81, 56 };
    int length = sizeof(scores) / sizeof(scores[0]);
    int sum = 0;
    /*
    sum += scores[0];
    sum += scores[1];
    sum += scores[2];
    sum += scores[3];
    sum += scores[4];
    */ // 반복문을 쓰지 않으면 이렇게 해야한다.

    for (int i = 0; i < length; i++)
    {
        sum += scores[i];
    }



    /****************************************************************************************
     * 배열과 포인터
     *
     * 같은 자료형을 연속적으로 배치하는 배열의 특징에 의해 C++는 배열과 포인터는 밀접한 관련이 있음 ************
     * 배열이 많은 배열 요소를 가지고 있어도 포인터를 활용하면 특정 요소에 빠른 접근이 가능 (단박에 접근이 가능하다)
     ****************************************************************************************/

     // <포인터 산술연산>
     // 포인터에 산술연산(+-)을 진행하는 경우 컴파일러는 자료형의 크기만큼 곱하여 연산을 진행
    int iValue = 0;
    int* intPtr = &iValue;
    cout << "int 포인터 변수의 주소값 " << intPtr << endl;
    cout << "int 포인터 변수에 -1을 진행하는 경우 " << intPtr - 1 << endl;
    cout << "int 포인터 변수에 +1을 진행하는 경우 " << intPtr + 1 << endl;

    double dValue = 0;
    double* doublePtr = &dValue;
    cout << "double 포인터 변수의 주소값 " << doublePtr << endl;
    cout << "double 포인터 변수에 -1을 진행하는 경우 " << doublePtr - 1 << endl;
    cout << "double 포인터 변수에 +1을 진행하는 경우 " << doublePtr + 1 << endl; // 포인터 변수에 산술연산을 하면 자료형 크기 만큼 뺴주거나 추가해준다. double의 경우 8바이트


    // <배열이름과 주소값>
    // C++에서 배열의 이름은 배열의 시작주소를 표현
    cout << "array 배열의 첫번째 요소의 주소는 " << &array[0] << endl;
    cout << "array 배열의 첫번째 요소의 값은 " << array[0] << endl;
    cout << "array 배열의 이름을 통한 첫번째 요소의 주소는 " << array << endl; // 배열의 주소를 적으면  첫번째 요소의 주소를 받는다.
    cout << "array 배열의 이름을 통한 첫번째 요소 값은" << *(array) << endl;


    // <배열 요소의 위치 추측>
    // 배열은 같은 자료형을 연속적으로 배치하는 특징을 가지고 있기 때문에 배열 요소의 위치를 계산을 통해 추측할 수 있음
    // 가장 처음 배열 요소로 부터 자료형의 크기만큼 간격을 두고 주소값을 가진다를 계산할 수 있음
    cout << "array 배열의 첫번째 요소의 주소는 " << &array[0] << endl;
    cout << "array 배열의 두번째 요소의 주소는 첫번쨰 요소로부터 자료형의 크기만큼 뒤에 있다고 계산할 수 있음" << endl;
    cout << "계산을 통해 확인한 두번째 요소의 주소는 " << &array[0] << " + " << sizeof(array[0]) << endl;
    cout << "array 배열의 두번째 요소의 주소는 " << &array[1] << endl;


    // <배열의 구현 원리>
    // C++ 문법 중 [](하위연산자)는 포인터 주소를 이용한 구현으로 진행됨
    // 배열이름[인덱스] 는 *(배열이름 + 인덱스) 으로 변환되어 처리됨, 이는 시작주소 + 인덱스 * 자료형의크기
    cout << "array 배열의 첫번째 요소의 주소 " << &array[0] << " , " << array + 0 << endl;
    cout << "array 배열의 두번째 요소의 주소 " << &array[1] << " , " << array + 1 << endl;
    cout << "array 배열의 세번째 요소의 주소 " << &array[2] << " , " << array + 2 << endl; 
   
    
    //array[0] ->* (array + 0); // 이렇게 쓰더라도 컴퓨터는 이와 같이 처리하는것과 같은 결과값을 내보낸다.
    //array[1] ->* (array + 1);
    array[0] = 1;
    array[1] = 2;
    array[2] = 3;
    cout << "array 배열의 첫번째 요소의 값 " << array[0] << " , " << *(array + 0) << endl;
    cout << "array 배열의 두번째 요소의 값 " << array[1] << " , " << *(array + 1) << endl;
    cout << "array 배열의 세번째 요소의 값 " << array[2] << " , " << *(array + 2) << endl;


    // <포인터 변수를 통한 배열 참조>
    // 배열은 포인터 변수를 이용하여 모든 동작이 가능
    // 단, 포인터 변수를 이용하는 경우 컴파일러가 배열 인덱스에 범위 밖에 대한 오류를 확인 할 수 없으니 주의
    const int* ptr = array; // 배열의 이름 자체가 배열의 시작지점이기때문에 받을수있다. // 배열 변수에 const 를 붙이면 원본 변경이 불가능하다. 
    cout << "포인터 변수를 통한 배열 요소 확인 " << ptr[0] << endl; // ptr[0] = *(ptr + 0) 이다.
    // ptr[6] = 10      // 주의! 포인터 변수를 통한 인덱스 범위 밖 연산은 위험함


 
    void copyarray(const int* array, int length);  // 배열의 값을 바꾸고 싶다하면 const 를 빼면된다. const int array[] 로 사용해도 같은 결과를 가진다.
    {
        for (int i = 0; i < length, i++;)
        {
            array[i] = 2;
        }
    }
}